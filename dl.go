// +build nobuild

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"sync"

	"github.com/PuerkitoBio/goquery"
	"github.com/pkg/errors"
	"golang.org/x/sync/errgroup"
)

func main() {
	fh, err := os.Create("generated.go")
	if err != nil {
		log.Fatal(err)
	}
	err = Download(fh)
	if closeErr := fh.Close(); closeErr != nil && err == nil {
		err = closeErr
	}
	if err != nil {
		log.Fatal(err)
	}
}

const concurrency = 8
const URL = "http://www.1000mostcommonwords.com/"

var rURL = regexp.MustCompile(
	`href="(` +
		strings.Replace(URL, "://www.", "://(?:www[.])?", 1) +
		`(?:words/)?1000-(?:most-)?common-([^-]+)-words)"`,
)

func Download(w io.Writer) error {
	resp, err := http.Get(URL)
	if err != nil {
		return errors.Wrap(err, URL)
	}
	b, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	bw := bufio.NewWriter(w)
	fmt.Fprintf(bw, `// Generated by dl.go, DO NOT EDIT!

package main

func init() {
`)
	limit := make(chan struct{}, concurrency)
	var mu sync.Mutex
	var grp errgroup.Group
	for _, loc := range rURL.FindAllSubmatchIndex(b, 100) {
		k, v := string(b[loc[2*2]:loc[2*2+1]]), b[loc[2*1]:loc[2*1+1]]
		v = bytes.Replace(v, []byte("/www."), []byte("/"), 1)
		v = bytes.Replace(v, []byte("/words/"), []byte("/"), 1)
		u := string(v)
		grp.Go(func() error {
			limit <- struct{}{}
			defer func() { <-limit }()

			log.Println(u)
			doc, qErr := goquery.NewDocument(u)
			if err := errors.Wrap(qErr, u); err != nil {
				return err
			}
			nth := "2"
			if strings.Contains(u, "-english-") {
				nth = "3"
			}
			var buf, lengths strings.Builder
			doc.Find(".entry-content > table > tbody > tr > td:nth-child(" + nth + ")").
				Each(func(i int, s *goquery.Selection) {
					text := s.Text()
					buf.WriteString(text)
					if i == 0 {
						return
					}
					if i != 1 {
						lengths.WriteByte(',')
					}
					fmt.Fprintf(&lengths, "%d", len(text))
				})
			if buf.Len() <= 1 {
				log.Printf("WARN: no words for %q in %q!", k, u)
				return nil
			}
			mu.Lock()
			fmt.Fprintf(bw, "\twordsMap[%q] = stringWithLengths{\n\t\tWords: %q,\n\t\tLengths: []uint8{%s},\n\t}\n",
				k, buf.String(), lengths.String())
			mu.Unlock()
			return nil
		})
	}

	err = errors.Wrap(err, URL)
	if wErr := grp.Wait(); wErr != nil && err == nil {
		err = wErr
	}
	bw.WriteString("\n}\n")
	if wErr := bw.Flush(); wErr != nil && err == nil {
		err = wErr
	}
	return err
}
